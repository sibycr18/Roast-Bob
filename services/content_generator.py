import logging
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import asyncio
from config.settings import (
    POSTING_INTERVAL_HOURS,
    CONTENT_LOG
)
from clients.bluesky_client import BlueskyClient
from clients.openai_client import OpenAIClient
from services.memory_service import MemoryService
from services.trend_analyzer import TrendAnalyzer

class ContentGenerator:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self._setup_logging()
        
        # Initialize clients and services
        self.bluesky = BlueskyClient()
        self.openai = OpenAIClient()
        self.memory = MemoryService()
        self.trend_analyzer = TrendAnalyzer()
        
        # Track post history
        self.last_post_time = None
        self.posted_topics = set()

    def _setup_logging(self):
        """Configure logging for content generator"""
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler = logging.FileHandler(CONTENT_LOG)
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)
        self.logger.setLevel(logging.INFO)

    def _should_post(self) -> bool:
        """Check if it's time to make a new post"""
        if not self.last_post_time:
            return True
            
        time_since_last = datetime.now() - self.last_post_time
        # return time_since_last >= timedelta(hours=POSTING_INTERVAL_HOURS)
        return True

    def _update_post_history(self, topics: List[str]):
        """Update tracking of posted topics"""
        self.posted_topics.update(topics)
        self.last_post_time = datetime.now()
        
        # Clear old topics after 24 hours
        if len(self.posted_topics) > 100:  # Arbitrary limit
            self.posted_topics.clear()

    async def _get_post_context(self) -> Dict:
        """Gather context for post generation"""
        try:
            # Get trending topics
            trending_topics = await self.trend_analyzer.get_trending_topics()
            
            # Filter out recently used topics
            fresh_topics = [
                topic for topic in trending_topics 
                if topic not in self.posted_topics
            ]
            
            if not fresh_topics:
                fresh_topics = trending_topics  # Reuse topics if all have been used
            
            # Get recent analyses for these topics
            context = []
            for topic in fresh_topics[:3]:  # Use top 3 topics
                opinions = await self.trend_analyzer.get_bot_opinions(topic)
                context.append({
                    "topics": topic,
                    "opinion": opinions[0] if opinions else "",
                    "future_post_ideas": ""  # Will be filled by OpenAI
                })
            
            return context
            
        except Exception as e:
            self.logger.error(f"Failed to get post context: {str(e)}")
            return []

    async def generate_post(self) -> Optional[str]:
        """Generate and post new content"""
        try:
            if not self._should_post():
                self.logger.info("Skipping post generation - too soon since last post")
                return None
            
            # Get context for post generation
            context = await self._get_post_context()
            
            if not context:
                self.logger.warning("No context available for post generation")
                return None
            
            # Generate post content
            post_content = await self.openai.generate_post(context)
            
            if post_content:
                # Post to Bluesky
                post_uri = self.bluesky.post_skeet(text=post_content)
                
                # Update tracking
                topics = [item["topics"] for item in context]
                self._update_post_history(topics)
                
                self.logger.info(f"Generated and posted content: {post_content[:50]}...")
                
                # Store the post and its context in memory
                self.memory.store_analysis(
                    {
                        "text": post_content,
                        "author": self.bluesky.handle,
                        "uri": post_uri,
                        "timestamp": datetime.now().isoformat()
                    },
                    {
                        "opinion": "Generated by bot",
                        "topics": topics,
                        "future_post_ideas": []
                    }
                )
                
                return post_uri
            
        except Exception as e:
            self.logger.error(f"Failed to generate post: {str(e)}")
            return None

    async def run_posting_cycle(self):
        """Run a complete posting cycle"""
        try:
            self.logger.info("Starting posting cycle")
            
            # Analyze trends first
            await self.trend_analyzer.run_analysis_cycle()
            
            # Generate and post content
            post_uri = await self.generate_post()
            
            if post_uri:
                self.logger.info(f"Posting cycle completed successfully. Post URI: {post_uri}")
            else:
                self.logger.info("Posting cycle completed - no post generated")
            
            return post_uri
            
        except Exception as e:
            self.logger.error(f"Posting cycle failed: {str(e)}")
            return None

    def get_post_schedule(self) -> Dict:
        """Get information about posting schedule"""
        next_post_time = None
        if self.last_post_time:
            next_post_time = self.last_post_time + timedelta(hours=POSTING_INTERVAL_HOURS)
            
        return {
            "last_post_time": self.last_post_time,
            "next_post_time": next_post_time,
            "posting_interval": POSTING_INTERVAL_HOURS,
            "topics_used": len(self.posted_topics)
        }